---
import "../styles/global.css";
import DecisionField from "../components/system/DecisionField.astro";

interface Props {
  title?: string;
}

const { title = "Aurora" } = Astro.props;
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Aurora. Infraestructura para decisiones críticas." />
    <title>{title}</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body data-regime="unstable" data-state="unstable" data-algorithm="core">
    <DecisionField />

    <header class="site-header">
      <div class="container-base site-header-inner">
        <a href="/" class="site-brand">
          <img src="/brand/aurora-symbol.png" alt="Aurora" class="brand-symbol" />
          <span class="brand-word">AURORA</span>
        </a>
        <nav class="site-nav" aria-label="Principal">
          <button
            type="button"
            class="site-nav-link site-products-trigger"
            id="site-products-trigger"
            aria-expanded="false"
            aria-controls="site-products-menu"
          >
            Productos
          </button>
          <a href="/demo" class="site-nav-link">Demo</a>
        </nav>
      </div>
      <div class="site-products-menu-wrap">
        <div id="site-products-menu" class="site-products-menu" hidden>
          <p class="site-products-kicker">Advanced Systems</p>
          <div class="site-products-list" role="list">
            <button type="button" class="site-product-item" data-product="counterfactual" role="listitem">
              <span class="site-product-name">Counterfactual Engine™</span>
              <span class="site-product-tech">Modela rutas alternativas bajo la misma restricción operativa.</span>
              <span class="site-product-impact">Te permite anticipar impacto antes de comprometer ejecución.</span>
            </button>
            <button type="button" class="site-product-item" data-product="regime-shift" role="listitem">
              <span class="site-product-name">Regime Shift Detector™</span>
              <span class="site-product-tech">Detecta cambios de estado cuando la señal aún es marginal.</span>
              <span class="site-product-impact">Te muestra cuándo un supuesto dejó de sostener la decisión.</span>
            </button>
            <button type="button" class="site-product-item" data-product="decision-entropy" role="listitem">
              <span class="site-product-name">Decision Entropy Map™</span>
              <span class="site-product-tech">Mapea dispersión causal y puntos de tensión en tiempo real.</span>
              <span class="site-product-impact">Te reduce fricción al concentrar foco en el nodo dominante.</span>
            </button>
          </div>
        </div>
      </div>
    </header>

    <main>
      <slot />
    </main>

    <footer id="contacto" class="site-footer">Aurora</footer>

    <script is:inline>
      const CONTROLLER_KEY = "__auroraRegimeController";
      const PRODUCT_ALGORITHM = {
        counterfactual: "scenario",
        "regime-shift": "risk",
        "decision-entropy": "integration",
      };

      const mountProductsMenu = () => {
        const trigger = document.getElementById("site-products-trigger");
        const menu = document.getElementById("site-products-menu");
        if (!trigger || !menu) return () => {};

        const items = Array.prototype.slice.call(menu.querySelectorAll("[data-product]"));
        let isOpen = false;

        const setAlgorithm = (productKey) => {
          document.body.dataset.menuProduct = productKey || "";
          document.body.dataset.algorithm = PRODUCT_ALGORITHM[productKey] || "core";
        };

        const open = () => {
          isOpen = true;
          trigger.setAttribute("aria-expanded", "true");
          menu.hidden = false;
        };

        const close = () => {
          isOpen = false;
          trigger.setAttribute("aria-expanded", "false");
          menu.hidden = true;
          items.forEach((item) => item.removeAttribute("data-active"));
          setAlgorithm("");
        };

        const onDocumentClick = (event) => {
          if (!isOpen) return;
          if (menu.contains(event.target) || trigger.contains(event.target)) return;
          close();
        };

        const onEscape = (event) => {
          if (event.key !== "Escape") return;
          if (!isOpen) return;
          close();
          trigger.focus();
        };

        const onTriggerClick = () => {
          if (isOpen) {
            close();
          } else {
            open();
          }
        };

        const onTriggerEnter = () => {
          if (window.matchMedia("(hover: hover)").matches) {
            open();
          }
        };

        trigger.addEventListener("click", onTriggerClick);
        trigger.addEventListener("mouseenter", onTriggerEnter);
        menu.addEventListener("mouseleave", () => {
          if (window.matchMedia("(hover: hover)").matches) close();
        });
        menu.addEventListener("mouseenter", open);
        document.addEventListener("click", onDocumentClick);
        document.addEventListener("keydown", onEscape);

        items.forEach((item) => {
          const activate = () => {
            const key = item.getAttribute("data-product");
            items.forEach((node) => node.removeAttribute("data-active"));
            item.setAttribute("data-active", "true");
            setAlgorithm(key);
          };
          item.addEventListener("mouseenter", activate);
          item.addEventListener("focus", activate);
          item.addEventListener("click", activate);
        });

        return () => {
          trigger.removeEventListener("click", onTriggerClick);
          trigger.removeEventListener("mouseenter", onTriggerEnter);
          document.removeEventListener("click", onDocumentClick);
          document.removeEventListener("keydown", onEscape);
          close();
        };
      };

      class RegimeController {
        constructor() {
          this.raf = 0;
          this.lastScrollY = window.scrollY;
          this.rawVelocity = 0;
          this.smoothVelocity = 0;
          this.hasScrolled = false;
          this.bootAt = performance.now();

          this.onScroll = this.onScroll.bind(this);
          this.onResize = this.onResize.bind(this);
          this.frame = this.frame.bind(this);

          window.addEventListener("scroll", this.onScroll, { passive: true, capture: true });
          window.addEventListener("resize", this.onResize, { passive: true });

          this.updateNow(performance.now());
          this.schedule();
        }

        destroy() {
          if (this.raf !== 0) {
            window.cancelAnimationFrame(this.raf);
            this.raf = 0;
          }
          window.removeEventListener("scroll", this.onScroll, true);
          window.removeEventListener("resize", this.onResize);
          delete document.body.dataset.scrollVelocity;
          delete document.body.dataset.binarySide;
        }

        onScroll() {
          const y = window.scrollY;
          this.rawVelocity = y - this.lastScrollY;
          this.lastScrollY = y;
          if (Math.abs(this.rawVelocity) > 0.4) {
            this.hasScrolled = true;
          }
          this.updateNow(performance.now());
          this.schedule();
        }

        onResize() {
          this.updateNow(performance.now());
          this.schedule();
        }

        schedule() {
          if (this.raf !== 0) return;
          this.raf = window.requestAnimationFrame(this.frame);
        }

        frame(now) {
          this.raf = 0;
          this.smoothVelocity = this.smoothVelocity * 0.84 + this.rawVelocity * 0.16;
          this.rawVelocity *= 0.34;
          this.updateNow(now);

          if (Math.abs(this.smoothVelocity) > 0.02) {
            this.schedule();
          }
        }

        updateNow(now) {
          const maxScroll = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
          const scrollProgress = Math.min(1, Math.max(0, window.scrollY / maxScroll));
          const introProgress = this.hasScrolled ? 0 : Math.min(1, (now - this.bootAt) / 3000);
          const effective = Math.max(scrollProgress, introProgress * 0.86);

          const regime = this.regimeByProgress(effective);
          document.body.dataset.regime = regime;
          document.body.dataset.state = regime;
          document.body.dataset.scrollVelocity = Math.abs(this.smoothVelocity).toFixed(3);

          this.syncBinaryBoundary();
        }

        regimeByProgress(progress) {
          if (window.location.pathname.startsWith("/demo")) return "stabilized";
          if (progress < 0.2) return "unstable";
          if (progress < 0.42) return "compressing";
          if (progress < 0.62) return "collision";
          if (progress < 0.74) return "rupture";
          if (progress < 0.9) return "reordering";
          return "stabilized";
        }

        syncBinaryBoundary() {
          const boundary = document.querySelector("[data-binary-boundary]");
          if (!boundary) {
            delete document.body.dataset.binarySide;
            return;
          }

          const rect = boundary.getBoundingClientRect();
          const numerator = window.innerHeight * 0.5 - rect.top;
          const progress = rect.height > 0 ? numerator / rect.height : -1;

          if (progress < 0 || progress > 1) {
            delete document.body.dataset.binarySide;
            return;
          }

          document.body.dataset.binarySide = progress < 0.5 ? "entropy" : "center";
        }
      }

      const mountRegimeController = () => {
        const scope = window;

        if (scope[CONTROLLER_KEY]) {
          scope[CONTROLLER_KEY].destroy();
        }

        const controller = new RegimeController();
        scope[CONTROLLER_KEY] = controller;

        return () => {
          controller.destroy();
          if (scope[CONTROLLER_KEY] === controller) {
            delete scope[CONTROLLER_KEY];
          }
        };
      };

      let cleanup;

      const boot = () => {
        if (typeof cleanup === "function") cleanup();
        const cleanupRegime = mountRegimeController();
        const cleanupMenu = mountProductsMenu();
        cleanup = () => {
          cleanupRegime();
          cleanupMenu();
        };
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot, { once: true });
      } else {
        boot();
      }

      window.addEventListener(
        "pagehide",
        () => {
          if (typeof cleanup === "function") cleanup();
        },
        { once: true }
      );
    </script>
  </body>
</html>
