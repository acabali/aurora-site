---
import "../styles/global.css";
import DecisionField from "../components/system/DecisionField.astro";

interface Props {
  title?: string;
}

type ProductGroup = {
  key: "motor" | "advanced";
  label: string;
  items: {
    key: string;
    name: string;
    tech: string;
    impact: string;
  }[];
};

const { title = "Aurora" } = Astro.props;

const PRODUCT_GROUPS: ProductGroup[] = [
  {
    key: "motor",
    label: "MOTOR ESTRUCTURAL",
    items: [
      {
        key: "core",
        name: "Core",
        tech: "Resuelve el nodo causal dominante con topologia estable de decision.",
        impact: "Recorta deriva ejecutiva y concentra recursos en la variable critica.",
      },
      {
        key: "scenario",
        name: "Scenario",
        tech: "Simula trayectorias bajo restricciones reales y umbrales compartidos.",
        impact: "Evita apuestas ciegas al comparar consecuencias antes del despliegue.",
      },
      {
        key: "risk",
        name: "Risk",
        tech: "Ubica puntos de ruptura y propaga severidad por dependencia causal.",
        impact: "Reduce exposicion material al priorizar mitigacion en nodo critico.",
      },
      {
        key: "signal",
        name: "Signal",
        tech: "Separa senal estructural de ruido operativo en ventanas cortas.",
        impact: "Acelera lectura de contexto sin degradar precision decisional.",
      },
      {
        key: "ledger",
        name: "Ledger",
        tech: "Traza hipotesis, evidencia y decision en una secuencia auditable.",
        impact: "Sostiene memoria institucional y evita repetir errores de criterio.",
      },
      {
        key: "integration",
        name: "Integration",
        tech: "Sincroniza criterios entre equipos con contratos de decision explicitos.",
        impact: "Disminuye friccion transversal y mantiene coherencia bajo presion.",
      },
    ],
  },
  {
    key: "advanced",
    label: "ADVANCED SYSTEMS",
    items: [
      {
        key: "counterfactual-engine",
        name: "Counterfactual Engine™",
        tech: "Genera rutas alternas consistentes con la misma carga operativa.",
        impact: "Permite elegir el curso con menor arrepentimiento ex post.",
      },
      {
        key: "regime-shift-detector",
        name: "Regime Shift Detector™",
        tech: "Detecta quiebres de regimen antes de impactar en indicadores rezagados.",
        impact: "Activa cambios de politica cuando el contexto invalida supuestos base.",
      },
      {
        key: "decision-entropy-map",
        name: "Decision Entropy Map™",
        tech: "Cuantifica dispersion causal y concentracion de incertidumbre por nodo.",
        impact: "Ordena prioridades ejecutivas cuando el entorno aumenta volatilidad.",
      },
    ],
  },
];
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Aurora. Infraestructura para decisiones criticas." />
    <title>{title}</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body data-regime="unstable" data-state="unstable" data-algorithm="core">
    <DecisionField />

    <header class="site-header">
      <div class="container-base site-header-inner">
        <a href="/" class="site-brand" aria-label="Aurora inicio">
          <img src="/brand/aurora-symbol.png" alt="Aurora" class="brand-symbol" />
          <span class="brand-word">AURORA</span>
        </a>

        <nav class="site-nav" aria-label="Principal">
          <button
            type="button"
            class="site-nav-link site-products-trigger"
            id="site-products-trigger"
            aria-expanded="false"
            aria-controls="site-products-menu"
          >
            Productos
          </button>
          <a href="/demo" class="site-nav-link">Demo</a>
        </nav>
      </div>

      <div class="site-products-menu-wrap" data-products-wrap hidden>
        <div id="site-products-menu" class="site-products-menu" role="region" aria-label="Productos Aurora">
          {PRODUCT_GROUPS.map((group) => (
            <section class="site-products-group" data-group={group.key}>
              <p class={`site-products-kicker${group.key === "advanced" ? " is-advanced" : ""}`}>
                {group.label}
              </p>
              <div class="site-products-list" role="list">
                {group.items.map((item) => (
                  <button
                    type="button"
                    class="site-product-item"
                    data-product-focus={item.key}
                    data-group-focus={group.key}
                    role="listitem"
                  >
                    <span class="site-product-name">{item.name}</span>
                    <span class="site-product-tech">{item.tech}</span>
                    <span class="site-product-impact">{item.impact}</span>
                  </button>
                ))}
              </div>
            </section>
          ))}
        </div>
      </div>
    </header>

    <main>
      <slot />
    </main>

    <footer id="contacto" class="site-footer">Aurora</footer>

    <script is:inline>
      const CONTROLLER_KEY = "__auroraRegimeController";
      const PRODUCT_ALGORITHM = {
        core: "core",
        scenario: "scenario",
        risk: "risk",
        signal: "signal",
        ledger: "ledger",
        integration: "integration",
        "counterfactual-engine": "scenario",
        "regime-shift-detector": "risk",
        "decision-entropy-map": "integration",
      };

      const setProductFocus = (productKey, groupKey) => {
        if (productKey) {
          document.body.dataset.productFocus = productKey;
        } else {
          delete document.body.dataset.productFocus;
        }

        if (groupKey) {
          document.body.dataset.groupFocus = groupKey;
        } else {
          delete document.body.dataset.groupFocus;
        }

        document.body.dataset.algorithm = PRODUCT_ALGORITHM[productKey] || "core";
      };

      const mountProductsMenu = () => {
        const trigger = document.getElementById("site-products-trigger");
        const wrap = document.querySelector("[data-products-wrap]");
        const menu = document.getElementById("site-products-menu");
        if (!trigger || !wrap || !menu) return () => {};

        const items = Array.prototype.slice.call(menu.querySelectorAll("[data-product-focus]"));
        const itemHandlers = [];
        let isOpen = false;

        const clearActive = () => {
          items.forEach((item) => item.removeAttribute("data-active"));
        };

        const open = () => {
          if (isOpen) return;
          isOpen = true;
          trigger.setAttribute("aria-expanded", "true");
          wrap.hidden = false;
        };

        const close = () => {
          isOpen = false;
          trigger.setAttribute("aria-expanded", "false");
          wrap.hidden = true;
          clearActive();
          setProductFocus("", "");
        };

        const activateItem = (item) => {
          const productKey = item.getAttribute("data-product-focus") || "";
          const groupKey = item.getAttribute("data-group-focus") || "";
          clearActive();
          item.setAttribute("data-active", "true");
          setProductFocus(productKey, groupKey);
        };

        const onDocumentClick = (event) => {
          if (!isOpen) return;
          const target = event.target;
          if (target instanceof Node && (wrap.contains(target) || trigger.contains(target))) return;
          close();
        };

        const onEscape = (event) => {
          if (event.key !== "Escape" || !isOpen) return;
          close();
          trigger.focus();
        };

        const onTriggerClick = () => {
          if (isOpen) {
            close();
            return;
          }
          open();
        };

        const onTriggerKeyDown = (event) => {
          if (event.key !== "ArrowDown") return;
          event.preventDefault();
          open();
          const firstItem = items[0];
          if (firstItem) firstItem.focus();
        };

        trigger.addEventListener("click", onTriggerClick);
        trigger.addEventListener("keydown", onTriggerKeyDown);
        document.addEventListener("click", onDocumentClick);
        document.addEventListener("keydown", onEscape);

        items.forEach((item) => {
          const activate = () => activateItem(item);
          itemHandlers.push({ item, activate });
          item.addEventListener("mouseenter", activate);
          item.addEventListener("focus", activate);
          item.addEventListener("click", activate);
        });

        return () => {
          trigger.removeEventListener("click", onTriggerClick);
          trigger.removeEventListener("keydown", onTriggerKeyDown);
          document.removeEventListener("click", onDocumentClick);
          document.removeEventListener("keydown", onEscape);

          itemHandlers.forEach(({ item, activate }) => {
            item.removeEventListener("mouseenter", activate);
            item.removeEventListener("focus", activate);
            item.removeEventListener("click", activate);
          });

          close();
        };
      };

      class RegimeController {
        constructor() {
          this.raf = 0;
          this.lastScrollY = window.scrollY;
          this.rawVelocity = 0;
          this.smoothVelocity = 0;
          this.hasScrolled = false;
          this.bootAt = performance.now();

          this.onScroll = this.onScroll.bind(this);
          this.onResize = this.onResize.bind(this);
          this.frame = this.frame.bind(this);

          window.addEventListener("scroll", this.onScroll, { passive: true, capture: true });
          window.addEventListener("resize", this.onResize, { passive: true });

          this.updateNow(performance.now());
          this.schedule();
        }

        destroy() {
          if (this.raf !== 0) {
            window.cancelAnimationFrame(this.raf);
            this.raf = 0;
          }
          window.removeEventListener("scroll", this.onScroll, true);
          window.removeEventListener("resize", this.onResize);
          delete document.body.dataset.scrollVelocity;
          delete document.body.dataset.binarySide;
        }

        onScroll() {
          const y = window.scrollY;
          this.rawVelocity = y - this.lastScrollY;
          this.lastScrollY = y;
          if (Math.abs(this.rawVelocity) > 0.4) {
            this.hasScrolled = true;
          }
          this.updateNow(performance.now());
          this.schedule();
        }

        onResize() {
          this.updateNow(performance.now());
          this.schedule();
        }

        schedule() {
          if (this.raf !== 0) return;
          this.raf = window.requestAnimationFrame(this.frame);
        }

        frame(now) {
          this.raf = 0;
          this.smoothVelocity = this.smoothVelocity * 0.84 + this.rawVelocity * 0.16;
          this.rawVelocity *= 0.34;
          this.updateNow(now);

          if (Math.abs(this.smoothVelocity) > 0.02) {
            this.schedule();
          }
        }

        updateNow(now) {
          const maxScroll = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
          const scrollProgress = Math.min(1, Math.max(0, window.scrollY / maxScroll));
          const introProgress = this.hasScrolled ? 0 : Math.min(1, (now - this.bootAt) / 3000);
          const effective = Math.max(scrollProgress, introProgress * 0.86);

          const regime = this.regimeByProgress(effective);
          document.body.dataset.regime = regime;
          document.body.dataset.state = regime;
          document.body.dataset.scrollVelocity = Math.abs(this.smoothVelocity).toFixed(3);

          this.syncBinaryBoundary();
        }

        regimeByProgress(progress) {
          if (window.location.pathname.startsWith("/demo")) return "stabilized";
          if (progress < 0.2) return "unstable";
          if (progress < 0.42) return "compressing";
          if (progress < 0.62) return "collision";
          if (progress < 0.74) return "rupture";
          if (progress < 0.9) return "reordering";
          return "stabilized";
        }

        syncBinaryBoundary() {
          const boundary = document.querySelector("[data-binary-boundary]");
          if (!boundary) {
            delete document.body.dataset.binarySide;
            return;
          }

          const rect = boundary.getBoundingClientRect();
          const numerator = window.innerHeight * 0.5 - rect.top;
          const progress = rect.height > 0 ? numerator / rect.height : -1;

          if (progress < 0 || progress > 1) {
            delete document.body.dataset.binarySide;
            return;
          }

          document.body.dataset.binarySide = progress < 0.5 ? "entropy" : "center";
        }
      }

      const mountRegimeController = () => {
        const scope = window;

        if (scope[CONTROLLER_KEY]) {
          scope[CONTROLLER_KEY].destroy();
        }

        const controller = new RegimeController();
        scope[CONTROLLER_KEY] = controller;

        return () => {
          controller.destroy();
          if (scope[CONTROLLER_KEY] === controller) {
            delete scope[CONTROLLER_KEY];
          }
        };
      };

      let cleanup;

      const boot = () => {
        if (typeof cleanup === "function") cleanup();
        const cleanupRegime = mountRegimeController();
        const cleanupMenu = mountProductsMenu();
        cleanup = () => {
          cleanupRegime();
          cleanupMenu();
        };
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot, { once: true });
      } else {
        boot();
      }

      window.addEventListener(
        "pagehide",
        () => {
          if (typeof cleanup === "function") cleanup();
        },
        { once: true }
      );
    </script>
  </body>
</html>
