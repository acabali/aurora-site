---
import "../styles/global.css";
import DecisionField from "../components/system/DecisionField.astro";

interface Props {
  title?: string;
}

const { title = "Aurora" } = Astro.props;
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="La era de la evidencia comenzÃ³." />
    <title>{title}</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body data-regime="unstable" data-state="unstable" data-algorithm="core">
    <DecisionField />

    <header class="site-header">
      <div class="container-base site-header-inner">
        <a href="/" class="site-brand">
          <img src="/brand/aurora-symbol.png" alt="Aurora" class="brand-symbol" />
          <span class="brand-word">AURORA</span>
        </a>
        <a href="#contacto" class="site-contact-link">Contactar</a>
      </div>
    </header>

    <main>
      <slot />
    </main>

    <footer id="contacto" class="site-footer">Aurora</footer>

    <script is:inline>
      const CONTROLLER_KEY = "__auroraRegimeController";

      class RegimeController {
        constructor() {
          this.raf = 0;
          this.lastScrollY = window.scrollY;
          this.rawVelocity = 0;
          this.smoothVelocity = 0;
          this.hasScrolled = false;
          this.bootAt = performance.now();

          this.onScroll = this.onScroll.bind(this);
          this.onResize = this.onResize.bind(this);
          this.frame = this.frame.bind(this);

          window.addEventListener("scroll", this.onScroll, { passive: true, capture: true });
          window.addEventListener("resize", this.onResize, { passive: true });

          this.updateNow(performance.now());
          this.schedule();
        }

        destroy() {
          if (this.raf !== 0) {
            window.cancelAnimationFrame(this.raf);
            this.raf = 0;
          }
          window.removeEventListener("scroll", this.onScroll, true);
          window.removeEventListener("resize", this.onResize);
          delete document.body.dataset.scrollVelocity;
          delete document.body.dataset.binarySide;
        }

        onScroll() {
          const y = window.scrollY;
          this.rawVelocity = y - this.lastScrollY;
          this.lastScrollY = y;
          if (Math.abs(this.rawVelocity) > 0.4) {
            this.hasScrolled = true;
          }
          this.updateNow(performance.now());
          this.schedule();
        }

        onResize() {
          this.updateNow(performance.now());
          this.schedule();
        }

        schedule() {
          if (this.raf !== 0) return;
          this.raf = window.requestAnimationFrame(this.frame);
        }

        frame(now) {
          this.raf = 0;
          this.smoothVelocity = this.smoothVelocity * 0.84 + this.rawVelocity * 0.16;
          this.rawVelocity *= 0.34;
          this.updateNow(now);

          if (Math.abs(this.smoothVelocity) > 0.02) {
            this.schedule();
          }
        }

        updateNow(now) {
          const maxScroll = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
          const scrollProgress = Math.min(1, Math.max(0, window.scrollY / maxScroll));
          const introProgress = this.hasScrolled ? 0 : Math.min(1, (now - this.bootAt) / 3000);
          const effective = Math.max(scrollProgress, introProgress * 0.86);

          const regime = this.regimeByProgress(effective);
          document.body.dataset.regime = regime;
          document.body.dataset.state = regime;
          document.body.dataset.scrollVelocity = Math.abs(this.smoothVelocity).toFixed(3);

          this.syncBinaryBoundary();
        }

        regimeByProgress(progress) {
          if (window.location.pathname.startsWith("/demo")) return "stabilized";
          if (progress < 0.2) return "unstable";
          if (progress < 0.42) return "compressing";
          if (progress < 0.62) return "collision";
          if (progress < 0.74) return "rupture";
          if (progress < 0.9) return "reordering";
          return "stabilized";
        }

        syncBinaryBoundary() {
          const boundary = document.querySelector("[data-binary-boundary]");
          if (!boundary) {
            delete document.body.dataset.binarySide;
            return;
          }

          const rect = boundary.getBoundingClientRect();
          const numerator = window.innerHeight * 0.5 - rect.top;
          const progress = rect.height > 0 ? numerator / rect.height : -1;

          if (progress < 0 || progress > 1) {
            delete document.body.dataset.binarySide;
            return;
          }

          document.body.dataset.binarySide = progress < 0.5 ? "entropy" : "center";
        }
      }

      const mountRegimeController = () => {
        const scope = window;

        if (scope[CONTROLLER_KEY]) {
          scope[CONTROLLER_KEY].destroy();
        }

        const controller = new RegimeController();
        scope[CONTROLLER_KEY] = controller;

        return () => {
          controller.destroy();
          if (scope[CONTROLLER_KEY] === controller) {
            delete scope[CONTROLLER_KEY];
          }
        };
      };

      let cleanup;

      const boot = () => {
        if (typeof cleanup === "function") cleanup();
        cleanup = mountRegimeController();
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot, { once: true });
      } else {
        boot();
      }

      window.addEventListener(
        "pagehide",
        () => {
          if (typeof cleanup === "function") cleanup();
        },
        { once: true }
      );
    </script>
  </body>
</html>
